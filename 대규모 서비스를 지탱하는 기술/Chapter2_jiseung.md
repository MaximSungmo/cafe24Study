# 대규모 데이터 처리의 어려운 점
## 대규모 데이터는 어떤 점이 어려운가?
+ 메모리 내에서 계산할 수 없다.
  + 메모리 내에서 계산할 수 없다면 디스크에 두고 특정 데이터를 검색한다 => 느린 속도
## 메모리와 디스크의 속도차
+ 약 10만배~100만배 정도 차이가 난다.
  + 디스크는 물리적인 작동이 수반하기 때문이다.
## OS 레벨에서의 연구
+ 데이터를 읽어올때 1byte씩 읽는게 아닌 약 4KB정도를 한꺼번에 읽어온다.
+ 비슷한 데이터를 비슷한 곳에 두어 최소한의 회전으로 정보를 읽어오게 한다.
## 전송속도, 버스의 속도차
+ 메모리가 디스크에 비해 탐색속도가 약 10만배~100만배 빠르지만 이것뿐만이 아니다.
+ 전송 속도 차이
  + 메모리 - CPU 약 7.5GB/초
  + 디스크는 약 54MB/초
  + 약 100배 이상 차이난다.
  - - -
# 규모조정의 요소
## 규모조정, 확장성
+ 웹 서비스에서 Scale-out전략이 적합한 이유
  + 비용이 저렴하다는 점과 시스템 구성에 유연성(*빠르게 대처 할 수 있다*)이 있다는 점이 포인트이다.
## 규모조정의 요소
**CPU부하와 I/O의 부하**
  + CPU부하가 소요되는 부분
    + ex) *웹 애플리케이션에서 계산을 수행할 때 즉, HTTP요청을 받아 DB에 질의하고 응답받은 데이터를 가공하여 HTML로 클라이언트에 반환할 때.
    AP서버(Application Server)가 담당할 일*
  + DB 서버 측면에선 I/O의 부하가 걸린다.
## 웹 애플리케이션과 부하의 관계
웹 애플리케이션의 3단 구조
1. 프록시
2. AP서버
3. DB
>프록시란?
서버와 클라이언트사이에서 중계하는 기능
프록시 서버에 요청이 된 내용들을 캐시를 이용해 저장해 둔다.
캐시로 저장해 두면 다시 데이터를 가져올 상황이 발생하지 않기 때문이다.

## DB 확장성 확보의 어려움
+ 대규모 환경에서는 I/O 부하를 부담하고 있는 서버는 애초에 분산시키기 어려움.
+ 디스크 I/O가 많이 발생하면 서버가 금새 느려지는 본질적인 문제.

# 대규모 데이터를 다루기 위한 기초지식
## 대규모 데이터를 다루는 세 가지 급소
>프로그램 작성할 때의 요령

1. 어떻게 하면 메모리에서 처리를 마칠 수 있을까?
    - 이유 : 디스크 seek 횟수를 최소화하기 위해
    - 확장성, 성능에 큰 영향
2. 데이터량 증가에 강한 알고리즘 사용
    - ex) 선형검색(**O(n)**) 보단 이분검색(**O(log n)**)
## 대규모 데이터를 다루기 전 3대 전제지식
1. OS 캐시
2. 분산을 고려해서 RDBMS 운용할 때 어떻게 해야 하는가
3. 대규모 환경에서 알고리즘과 데이터 구조를 사용한다는 것은 어떤 것인가.
